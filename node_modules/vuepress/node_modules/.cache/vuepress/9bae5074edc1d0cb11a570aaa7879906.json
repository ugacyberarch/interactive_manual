{"remainingRequest":"/Users/sammyvo/cyberarch-manual/node_modules/babel-loader/lib/index.js??ref--3-1!/Users/sammyvo/cyberarch-manual/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/sammyvo/cyberarch-manual/docs/.vuepress/components/Password/Cracker.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/sammyvo/cyberarch-manual/docs/.vuepress/components/Password/Cracker.vue","mtime":1602086742467},{"path":"/Users/sammyvo/cyberarch-manual/node_modules/cache-loader/dist/cjs.js","mtime":1602086795963},{"path":"/Users/sammyvo/cyberarch-manual/node_modules/babel-loader/lib/index.js","mtime":1602086795925},{"path":"/Users/sammyvo/cyberarch-manual/node_modules/vue-loader/lib/index.js","mtime":1602086796509}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.array.fill\";\nimport _toConsumableArray from \"/Users/sammyvo/cyberarch-manual/node_modules/@babel/runtime/helpers/builtin/es6/toConsumableArray\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.array.reduce\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport anime from 'animejs';\nimport * as _ from 'lodash';\n\nvar hsimp = require('./hsimp');\n/*\n * Find the nth set in a cartesian product of sets:\n *  N = size(A) * size(B) * ... * size(Z)\n *  c(i) = [A[i_a], B[i_b], ... Z[i_z]]\n *  i_a = i/(size(B)*size(C)*...*size(Z))\n *  i_b = (i/size(C)*...*size(z-1)) mod size(B)\n *  ...\n *  i_z = i mod size(Z)\n */\n\n\nfunction nthProduct(sets, n) {\n  var indices = [];\n\n  var tsize = function tsize(i) {\n    return sets.slice(i).map(function (s) {\n      return s.length;\n    }).reduce(function (acc, v) {\n      return acc * v;\n    });\n  };\n\n  if (sets.length > 1) {\n    indices.push(Math.floor(n / tsize(1)));\n\n    for (var j = 1; j < sets.length - 1; j++) {\n      indices.push(Math.floor(n / tsize(j + 1) % sets[j].length));\n    }\n  }\n\n  indices.push(n % sets[sets.length - 1].length);\n  return indices.map(function (i_x, i) {\n    return sets[i][i_x];\n  });\n}\n\nexport default {\n  props: ['password', 'speed'],\n  data: function data() {\n    return {\n      chars: [],\n      tasks: [],\n      counter: 0\n    };\n  },\n  computed: {\n    digit: function digit() {\n      return /[0-9]/.test(this.password);\n    },\n    lower: function lower() {\n      return /[a-z]/.test(this.password);\n    },\n    upper: function upper() {\n      return /[A-Z]/.test(this.password);\n    },\n    symbol: function symbol() {\n      return /[$-/:-?{-~!\"^_`\\[\\]]/.test(this.password);\n    },\n    alpha: function alpha() {\n      var sets = [];\n\n      if (this.symbol) {\n        sets = sets.concat(_.range(0x20, 0x30));\n      }\n\n      if (this.upper) {\n        sets = sets.concat(_.range(0x41, 0x5b));\n      }\n\n      if (this.digit) {\n        sets = sets.concat(_.range(0x30, 0x3a));\n      }\n\n      if (this.symbol) {\n        sets = sets.concat(_.range(0x3a, 0x41));\n      }\n\n      if (this.lower) {\n        sets = sets.concat(_.range(0x61, 0x7b));\n      }\n\n      if (this.symbol) {\n        sets = sets.concat(_.range(0x7b, 0x7f));\n      }\n\n      return new Set(_.flatten(sets));\n    },\n    guess: function guess() {\n      var chars = this.chars.slice().reverse();\n      return String.fromCharCode.apply(String, _toConsumableArray(chars));\n    },\n    passwordsPerSecond: function passwordsPerSecond() {\n      return Math.pow(10, this.speed) * 4;\n    },\n    percentDone: function percentDone() {\n      var possible = this.possibleCombinations || 1;\n      var pct = this.counter / possible * 100; //return Math.round(pct * 100) / 100\n\n      return Math.ceil(pct);\n    },\n    possibleCombinations: function possibleCombinations() {\n      return Math.pow(this.alpha.size, this.password.length);\n    },\n    progress: function progress() {\n      var count = hsimp.namedNumber(this.counter).getName();\n      var total = hsimp.namedNumber(this.possibleCombinations).getName();\n      return count + ' of ' + total;\n    },\n    timeRemaining: function timeRemaining() {\n      var remaining = this.possibleCombinations - this.counter;\n      var time = remaining / this.passwordsPerSecond;\n      var period = hsimp.period(time);\n      var periodLength = period.getLength();\n      var formattedPeriodLength = hsimp.namedNumber(periodLength).getName();\n      var periodName = formattedPeriodLength === \"1\" ? period.getSingular() : period.getPlural();\n      var periodString = formattedPeriodLength + \" \" + periodName;\n      return periodString;\n    }\n  },\n  watch: {\n    guess: function guess(newGuess, oldGuess) {\n      if (newGuess == this.password) {\n        this.pause();\n        this.counter = this.possibleCombinations;\n      }\n\n      if (newGuess.length > this.password.length) {\n        this.pause();\n        this.chars = _.invokeMap(this.password, 'charCodeAt').reverse();\n        this.counter = this.possibleCombinations;\n      }\n    }\n  },\n  methods: {\n    reset: function reset() {\n      this.pause();\n      this.chars = [];\n      this.counter = 0;\n      this.$emit('reset');\n    },\n    fudge: function fudge() {\n      var _this = this;\n\n      // TODO: fix fudge after reset\n      if (this.speed < 2) {\n        return;\n      } // We don't actually guess passwords very fast, so we can cheat and\n      // skip ahead in the sequence. Since we already know the password, we\n      // we can't miss it.\n\n\n      anime({\n        targets: this,\n        counter: this.counter + this.passwordsPerSecond,\n        round: 1,\n        duration: 1000,\n        easing: 'easeInOutQuint',\n        update: function update() {\n          var _this$chars;\n\n          // Possible values per character\n          var base = _this.alpha.size; // Number of characters\n\n          var nchars = Math.ceil(Math.log(_this.counter) / Math.log(base)); // Offset into sequences of length nchars\n\n          var i = _this.counter % Math.pow(base, nchars); // Find sequence at offset\n\n          var seq = nthProduct(_.fill(Array(nchars), Array.from(_this.alpha)), i); // Skip to sequence\n\n          (_this$chars = _this.chars).splice.apply(_this$chars, [0, seq.length].concat(_toConsumableArray(seq.reverse())));\n        }\n      });\n    },\n    next: function next(seq, start, stop) {\n      // Next string in sequence\n      this.counter++;\n      var i = 0;\n\n      while (seq[i] == stop) {\n        //seq[i++] = start \n        this.$set(seq, i++, start);\n      }\n\n      if (i == seq.length) {\n        seq.push(start);\n        return;\n      } //seq[i]++\n\n\n      this.$set(seq, i, seq[i] + 1);\n    },\n    crack: function crack() {\n      var start = Math.min.apply(Math, _toConsumableArray(this.alpha));\n      var stop = Math.max.apply(Math, _toConsumableArray(this.alpha)); // Simulate guesses per second.\n\n      this.tasks.push(setInterval(this.fudge, 900)); // Continuously increment string\n\n      this.tasks.push(setInterval(this.next, 100, this.chars, start, stop));\n    },\n    pause: function pause() {\n      _.each(this.tasks, clearInterval);\n\n      this.tasks = [];\n    }\n  }\n};",{"version":3,"sources":["Cracker.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"password-cracker\">\n\n    <div class=\"guess\">\n      <input class=\"password\" v-bind:value=\"guess\" disabled />\n\n      <div class=\"buttons\">\n        <button v-on:click=\"reset\">Reset</button>\n        <button v-on:click=\"pause\" :disabled=\"tasks.length == 0\">Pause</button>\n        <button v-on:click=\"crack\" :disabled=\"tasks.length > 0\">Crack</button>\n      </div>\n    </div>\n\n    <div class=\"progress\">\n      <div class=\"bar\">\n        <div class=\"fill\" v-bind:style=\"{ width: percentDone + '%' }\"></div>\n      </div>\n      <span>{{ percentDone }}%</span>\n    </div>\n\n    <div class=\"characters\">\n      <i v-bind:class=\"{ active: digit }\">digit</i>\n      <i v-bind:class=\"{ active: lower }\">lower</i>\n      <i v-bind:class=\"{ active: upper }\">upper</i>\n      <i v-bind:class=\"{ active: symbol }\">symbol</i>\n    </div>\n\n    <div class=\"speed\">\n      <input\n        v-bind:value=\"speed\"\n        v-on:input=\"$emit('change-speed', $event.target.value)\"\n        class=\"slider\"\n        type=\"range\" min=\"1\" max=\"10\" step=\"1\" />\n      <span>{{ passwordsPerSecond.toLocaleString() }}/second</span>\n    </div>\n\n    <div style=\"clear:both;\"></div>\n\n    <div v-if=\"false\" class=\"time\">\n      <div>Tried {{ progress }}</div>\n      Estimated time remaining:<br>\n      {{ timeRemaining }}\n    </div>\n\n  </div>\n</template>\n\n<script>\nimport anime from 'animejs';\nimport * as _ from 'lodash';\n\nconst hsimp = require('./hsimp')\n\n/*\n * Find the nth set in a cartesian product of sets:\n *  N = size(A) * size(B) * ... * size(Z)\n *  c(i) = [A[i_a], B[i_b], ... Z[i_z]]\n *  i_a = i/(size(B)*size(C)*...*size(Z))\n *  i_b = (i/size(C)*...*size(z-1)) mod size(B)\n *  ...\n *  i_z = i mod size(Z)\n */\nfunction nthProduct(sets, n) {\n  let indices = [];\n\n  let tsize = (i) => sets\n    .slice(i)\n    .map((s) => s.length)\n    .reduce((acc,v) => acc * v);\n\n  if (sets.length > 1) {\n    indices.push(Math.floor( n / tsize(1) ));\n\n    for (var j = 1; j < (sets.length - 1); j++) {\n      indices.push(Math.floor( (n / tsize(j + 1)) % sets[j].length ))\n    }\n  }\n  indices.push( n % sets[sets.length - 1].length );\n\n  return indices.map((i_x,i) => sets[i][i_x]);\n}\n\nexport default {\n  props: ['password', 'speed'],\n\n  data() {\n    return {\n      chars: [],\n      tasks: [],\n      counter: 0,\n    }\n  },\n\n  computed: {\n    digit() {\n      return /[0-9]/.test(this.password)\n    },\n    lower() {\n      return /[a-z]/.test(this.password)\n    },\n    upper() {\n      return /[A-Z]/.test(this.password)\n    },\n    symbol() {\n      return /[$-/:-?{-~!\"^_`\\[\\]]/.test(this.password)\n    },\n    alpha() {\n      var sets = [];\n      if (this.symbol) { sets = sets.concat(_.range(0x20, 0x30)) }\n      if (this.upper) { sets = sets.concat(_.range(0x41, 0x5b)) }\n      if (this.digit) { sets = sets.concat(_.range(0x30, 0x3a)) }\n      if (this.symbol) { sets = sets.concat(_.range(0x3a, 0x41)) }\n      if (this.lower) { sets = sets.concat(_.range(0x61, 0x7b)) }\n      if (this.symbol) { sets = sets.concat(_.range(0x7b, 0x7f)) }\n      return new Set(_.flatten(sets))\n    },\n    guess() {\n      let chars = this.chars.slice().reverse();\n      return String.fromCharCode(...chars);\n    },\n    passwordsPerSecond() {\n      return Math.pow(10, this.speed) * 4;\n    },\n    percentDone() {\n      let possible = (this.possibleCombinations || 1);\n      let pct = (this.counter / possible) * 100;\n      //return Math.round(pct * 100) / 100\n      return Math.ceil(pct);\n    },\n    possibleCombinations() {\n      return Math.pow(this.alpha.size, this.password.length);\n    },\n    progress() {\n      let count = hsimp.namedNumber(this.counter).getName();\n      let total = hsimp.namedNumber(this.possibleCombinations).getName();\n      return count + ' of ' + total;\n    },\n    timeRemaining() {\n      let remaining = this.possibleCombinations - this.counter;\n      let time = remaining / this.passwordsPerSecond;\n\n      let period = hsimp.period(time)\n      let periodLength = period.getLength()\n\n      let formattedPeriodLength = hsimp.namedNumber(periodLength).getName();\n      let periodName = formattedPeriodLength === \"1\"\n          ? period.getSingular()\n          : period.getPlural();\n\n      let periodString = formattedPeriodLength + \" \" + periodName;\n\n      return periodString\n    },\n  },\n\n  watch: {\n    guess(newGuess, oldGuess) {\n      if (newGuess == this.password) {\n        this.pause()\n        this.counter = this.possibleCombinations\n      }\n      if (newGuess.length > this.password.length) {\n        this.pause()\n        this.chars = _.invokeMap(this.password, 'charCodeAt').reverse()\n        this.counter = this.possibleCombinations\n      }\n    },\n  },\n\n  methods: {\n    reset() {\n      this.pause();\n      this.chars = [];\n      this.counter = 0;\n      this.$emit('reset');\n    },\n    fudge() {\n      // TODO: fix fudge after reset\n      if (this.speed < 2) { return }\n\n      // We don't actually guess passwords very fast, so we can cheat and\n      // skip ahead in the sequence. Since we already know the password, we\n      // we can't miss it.\n      anime({\n        targets: this,\n        counter: this.counter + this.passwordsPerSecond,\n        round: 1,\n        duration: 1000,\n        easing: 'easeInOutQuint',\n        update: () => {\n          // Possible values per character\n          let base = this.alpha.size\n          // Number of characters\n          let nchars = Math.ceil(Math.log(this.counter) / Math.log(base));\n          // Offset into sequences of length nchars\n          let i = this.counter % Math.pow(base, nchars)\n          // Find sequence at offset\n          let seq = nthProduct(_.fill(Array(nchars), Array.from(this.alpha)), i)\n          // Skip to sequence\n          this.chars.splice(0, seq.length, ...seq.reverse())\n        }\n      });\n\n    },\n    next(seq, start, stop) {\n      // Next string in sequence\n      this.counter++\n\n      let i = 0\n      while (seq[i] == stop) {\n        //seq[i++] = start \n        this.$set(seq, i++, start)\n      }\n      if (i == seq.length) {\n        seq.push(start)\n        return\n      }\n      //seq[i]++\n      this.$set(seq, i, seq[i] + 1)\n    },\n    crack() {\n      let start = Math.min(...this.alpha)\n      let stop = Math.max(...this.alpha)\n\n      // Simulate guesses per second.\n      this.tasks.push(setInterval(this.fudge, 900))\n\n      // Continuously increment string\n      this.tasks.push(setInterval(this.next, 100, this.chars, start, stop))\n    },\n    pause() {\n      _.each(this.tasks, clearInterval)\n      this.tasks = []\n    },\n  }\n}\n</script>\n\n<style scoped>\n.password-cracker {\n  padding: 0 20px;\n}\n\ninput.password {\n  box-sizing: border-box;\n  display: inline-block;\n\n  color: white;\n  text-align: center;\n  font-size: 32px;\n\n  width: 100%;\n  margin: 8px 0;\n  padding-right: 10px;\n\n  border: none;\n  background: none;\n}\n\n.guess {\n  position: relative;\n}\n\n.buttons {\n  position: absolute;\n  right: 0px;\n  top: 20px;\n}\n\n.buttons button {\n  font-size: 14px;\n  color: #FFF;\n  padding: 2px 10px;\n  margin-left: 8px;\n  display: inline-block;\n  border: 1px solid white;\n  background: none;\n}\n\n.buttons button:hover {\n  background: #fff;\n  color: #333;\n}\n\n.buttons button:disabled {\n  opacity: 0.4;\n}\n\n/* Progress bar */\n.progress {\n  display: block;\n  width: 100%;\n  text-align: center;\n}\n\n.progress span {\n  line-height: 24px;\n  padding-left: 4px;\n  color: #FFF;\n}\n\n.progress .bar {\n  width: 100%;\n  height: 4px;\n  background-color: #f1f1f1;\n  text-align: center !important;\n  opacity: 0.4;\n}\n\n.progress .fill {\n  height: 100%;\n  background-color: #2196F3;\n  margin: 0;\n  padding: 0;\n  text-align: center;\n}\n\n/* Character indicators */\n.characters {\n  display: block;\n  text-align: left;\n  height: 24px;\n  margin-top: -14px;\n  opacity: 0.5;\n}\n\n.characters i {\n  font-size: 12px;\n  border: 1px solid #ccc;\n  padding: 2px 4px;\n  margin: 0 4px;\n  background: white;\n}\n\n.characters i.active {\n opacity: 1;\n background-color: green;\n color: #FFF;\n border: 1px solid #4CAF50 !important;\n}\n\n/* Speed slider */\n.speed {\n  display: inline-block;\n  float: right;\n\n  color: #FFF;\n  font-size: 12px;\n  text-align: center;\n\n  width: 200px;\n  margin-top: -24px;\n}\n\n.speed label {\n  display: block;\n  margin: 0 auto;\n}\n\n.speed span {\n  display: block;\n  margin: 0 auto;\n}\n\n.speed input {\n  display: block;\n  width: 100%;\n}\n\n.slider {\n    -webkit-appearance: none;\n    width: 100%;\n    height: 6px;\n    background: #d3d3d3;\n    outline: none;\n    opacity: 0.7;\n    -webkit-transition: .2s;\n    transition: opacity .2s;\n    border-radius: 5px;\n    margin: 8px 0;\n}\n\n.slider:hover {\n    opacity: 1;\n}\n\n.slider::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    appearance: none;\n    width: 14px;\n    height: 14px;\n    background: #FFF;\n    cursor: pointer;\n    border-radius: 50%;\n}\n\n.slider::-moz-range-thumb {\n    width: 14px;\n    height: 14px;\n    background: #FFF;\n    cursor: pointer;\n    border-radius: 50%;\n}\n\ninput[type='range']::-moz-focus-outer {\n  border: 0;\n}\n\n\n</style>\n"],"sourceRoot":"docs/.vuepress/components/Password"}]}